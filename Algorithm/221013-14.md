# 22/10/13-14 프로그래머스 알고리즘 강의 공부
#### 강의: [[JAVA]어서와! 자료구조와 알고리즘은 처음이지?](https://school.programmers.co.kr/learn/courses/13577)
***

## ⚠ Sort &rarr; 순서 바꾸기

*** 

## Sort (정렬)

1. Bubble Sort      &rarr; O(n<sup>2</sup>)
2. Insertion Sort   &rarr; O(n<sup>2</sup>)
3. Selection Sort   &rarr; O(n<sup>2</sup>)
4. Quick Sort       &rarr; O(nlogn)
5. Merge Sort       &rarr; O(nlogn)

<br>

|           |  Best   | Average |  Worst   | 
|:---------:|:-------:|:-------:|:--------:|
|  Bubble   |    n    | n<sup>2 | n<sup>2  |  
| Insertion |  O(1)   | n<sup>2 | n<sup>2  |    
| Selection | n<sup>2 | n<sup>2 | n<sup>2  |    
|   Quick   |  nlogn  |  nlogn  | n<sup>2  | 
|   Merge   |  nlogn  |  nlogn  | nlogn    |   

*** 

# Sortable Interface
정렬 알고리즘을 직접 구현해봅니다.
입력으로 List와 Comparator를 제공하고, 원본은 유지하고 정렬된 새로운 List를 반환하는 형태로 개발합니다. <br>
그래서 Sort 기능을 추상화하여 이러한 인터페이스를 만들고 각 구현체는 이 인터페이스를 구현하도록 합니다. <br>

```java
import java.util.Comparator;
import java.util.List;

public interface Sortable {
    <T> List<T> sort(List<T> list, Comparator<t> comparator);
}
```

제너릭 타입 T를 사용하고 있는데, 특별히 T가 Comparable을 구현하고 있을 때 Comparator를 제공할 필요는 없습니다. <br>
그래서 default 메소드도 추가합니다.

```java
import java.util.Comparator;
import java.util.List;

public interface Sortable {
    <T> List<T> sort(List<T> list, Comparator<T> comparator);
    
    default <T extends Comparable> List<T> sort<List<T> list) {
        return sort(list, Comparable::compareTo);
    }
}
```
이제 알고리즘 별로 구현제를 만들어봅니다.
## BubbleSort Code
```java
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

public class BubbleSort implements Sortable {
    @Override
    public <T> List<T> sort(List<T> list, Comparator<T> comparator) {
        List<T> copy = new LinkedList<>(list);
        int size = copy.size();
        for (int i=0 ; i < size ; i++){
            for(int j=i+1 ; j<size ; j++){
                T d1 = copy.get(i);
                T d2 = copy.get(j);
                if (comparator.compare(d1, d2) > 0) {
                    copy.set(i, d2);
                    copy.set(j, d1);
                }
            }
        }
        return copy;
    }
}
```
인자로 전달되는 `list`로부터 복사본 리스트인 `copy`를 만들어서 순서를 교체해서 정렬을 수행하고 있습니다. <br>
여기서 사용되는 제너릭 타입 T는 레퍼런스 타입입니다. 복사본을 만든다는 것은 참조값을 만들어 복사하고, 참조값들의 배치를 재정렬하는 것입니다.<br>
실제 객체 자체가 교체되거나 하지는 않는다는 것을 기억해야 합니다.<br>
## InsertSort Code
```java
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

public class SelectionSort implements Sortable {
    @Override 
    public <T> List<T> sort(List<T> list, Comparator<T> comparator) {
        List<T> copy = new LinkedList<>(list);
        int size = copy.size();
        
        for (int i=0 ; i<size ; i++) {
            int minIndex = i;
            T min = copy.get(i);
            
            for(int j=0 ; j<size ; j++){
                T d = copy.get(j);
                if (min == null || comparator.compare(min, d) > 0){
                    minIndex = j;
                    min = d;
                }
            }
            copy.remove(minIndex);
            copy.add(i, min);
        }
        return copy;
    }
}
```
내부 for-loop에서 최소값을 찾아내는 과정에서, 반복 범위 중 첫번째 요소 min으로 먼저 지정하고 나서 <br>
나머지 요소중에서 min을 업데이트 하면서 찾아내는 방식으로 구현되어 있습니다.

## SelectionSort Code

## QuickSort Code

## MergeSort Code

